\documentclass{article}
\usepackage{amsmath, amssymb}
\usepackage{bm}
\usepackage{geometry}
\geometry{margin=1in}

\title{Constrained Dynamics of Mechanical Systems}
\author{}
\date{}

\begin{document}

\maketitle

\section{Preliminaries}

We consider a mechanical system with configuration \( \bm{q} \in \mathbb{R}^n \)
and generalized velocity \( \bm{v} \in \mathbb{R}^m \). The system evolves
according to:

\begin{equation}
    \bm{M}(\bm{q}) \dot{\bm{v}} + \bm{c}(\bm{q}, \bm{v}) = \bm{\tau},
\end{equation}

where:
\begin{itemize}
    \item \( \bm{M}(\bm{q}) \in \mathbb{R}^{m \times m} \) is the generalized
    mass matrix,
    \item \( \bm{c}(\bm{q}, \bm{v}) \in \mathbb{R}^m \) includes Coriolis and
    centrifugal effects,
    \item \( \bm{\tau} \in \mathbb{R}^m \) is the generalized force.
\end{itemize}

The generalized coordinates evolve according to the kinematic relation:

\begin{equation}
    \dot{\bm{q}} = \bm{N}(\bm{q}) \bm{v},
\end{equation}

where \( \bm{N}(\bm{q}) \in \mathbb{R}^{n \times m} \) is the kinematics map.

Holonomic constraints are defined as:

\begin{equation}
    \bm{\Phi}(\bm{q}, t) = \bm{0},
\end{equation}

where \( \bm{\Phi}: \mathbb{R}^n \times \mathbb{R} \rightarrow \mathbb{R}^k \)
is differentiable.

\section{Constrained Dynamics at the Acceleration Level}

Differentiating the constraint and enforcing it at the acceleration level gives:

\begin{equation}
    \bm{J}(\bm{q}, t) \bm{N}(\bm{q}) \dot{\bm{v}} + \dot{\bm{J}}(\bm{q}, t) \bm{N}(\bm{q}) \bm{v} = -\frac{\partial \bm{\Phi}}{\partial t},
\end{equation}

where \( \bm{J} = \partial \bm{\Phi} / \partial \bm{q} \) is the constraint
Jacobian.

We enforce the constraints using Lagrange multipliers \( \bm{\lambda} \in
\mathbb{R}^k \), resulting in:

\begin{equation}
    \bm{M}(\bm{q}) \dot{\bm{v}} + \bm{c}(\bm{q}, \bm{v}) = \bm{\tau} + \bm{N}(\bm{q})^\top \bm{J}^\top(\bm{q}, t) \bm{\lambda}.
\end{equation}

\section{Discrete Velocity-Level Formulation}

To decouple integration and constraint enforcement, we use an operator splitting
strategy.

Let \( \bm{v}^* \) be the unconstrained velocity obtained using any integration
scheme (explicit or implicit) applied to:

\begin{equation}
    \bm{M}(\bm{q}^n) \dot{\bm{v}} + \bm{c}(\bm{q}^n, \bm{v}) = \bm{\tau}.
\end{equation}

We then correct the velocity to satisfy the constraints by solving:

\begin{equation}
    \bm{M}(\bm{q}^n)(\bm{v}^{n+1} - \bm{v}^*) = \bm{N}(\bm{q}^n)^\top \bm{J}^\top(\bm{q}^n) \bm{\lambda}^{n+1}.
\end{equation}

The constraint at the velocity level is:

\begin{equation}
    \bm{J}(\bm{q}^n) \bm{N}(\bm{q}^n) \bm{v}^{n+1} = -\frac{\bm{\Phi}(\bm{q}^n, t^{n+1})}{\Delta t}.
\end{equation}

\section{Constraint Stabilization}

\subsection{Projection}

Numerical integration of the dynamics often causes constraint drift, where \(
\bm{\Phi}(\bm{q}, t) \neq 0 \) due to accumulated numerical errors. The
projection method corrects this drift by mapping the configuration \( \bm{q}^*
\) back onto the constraint manifold.

Let \( \bm{q}^* \) be a tentative configuration that does not satisfy the
constraint \( \bm{\Phi}(\bm{q}^*, t) \approx \bm{\varepsilon} \neq \bm{0} \).
The goal is to find the corrected configuration \( \bm{q}_{\text{proj}} \) such
that:

\begin{equation}
    \bm{\Phi}(\bm{q}_{\text{proj}}, t) = \bm{0},
\end{equation}

and \( \bm{q}_{\text{proj}} \) is as close as possible to \( \bm{q}^* \). This
is a constrained optimization problem:

\begin{equation}
    \bm{q}_{\text{proj}} = \arg\min_{\bm{q}} \frac{1}{2} \| \bm{q} - \bm{q}^* \|^2 \quad \text{subject to} \quad \bm{\Phi}(\bm{q}, t) = \bm{0}.
\end{equation}

\subsubsection*{Linearization and Newton Iteration}

Assuming \( \bm{q}^* \) is close to the constraint manifold, we perform a
first-order Taylor expansion of the constraint:

\begin{equation}
    \bm{\Phi}(\bm{q}_{\text{proj}}, t) \approx \bm{\Phi}(\bm{q}^*, t) + \bm{J}(\bm{q}^*, t)(\bm{q}_{\text{proj}} - \bm{q}^*) = \bm{0},
\end{equation}

where \( \bm{J}(\bm{q}, t) = \frac{\partial \bm{\Phi}}{\partial \bm{q}} \) is
the constraint Jacobian. Rearranging gives a linear system for the correction \(
\Delta \bm{q} \equiv \bm{q}_{\text{proj}} - \bm{q}^* \):

\begin{equation}
    \bm{J}(\bm{q}^*, t) \Delta \bm{q} = -\bm{\Phi}(\bm{q}^*, t).
\end{equation}

To compute \( \Delta \bm{q} \) efficiently and minimize its norm, we solve the
least-squares problem using the pseudoinverse:

\begin{equation}
    \Delta \bm{q} = -\bm{J}^\top(\bm{J} \bm{J}^\top)^{-1} \bm{\Phi}(\bm{q}^*, t),
\end{equation}

so the projected configuration becomes:

\begin{equation}
    \bm{q}_{\text{proj}} = \bm{q}^* - \bm{J}^\top(\bm{J} \bm{J}^\top)^{-1} \bm{\Phi}(\bm{q}^*, t).
\end{equation}

This operation projects \( \bm{q}^* \) orthogonally onto the constraint surface,
in the Euclidean sense.

\subsubsection*{Iterative Newton-Raphson Correction}

The linearized update is only locally accurate. To enforce the constraint up to
a desired tolerance, we apply the correction iteratively. At each iteration \( k
\), we compute:

\begin{align}
    \bm{\Phi}_k &= \bm{\Phi}(\bm{q}_k, t), \\
    \bm{J}_k &= \frac{\partial \bm{\Phi}}{\partial \bm{q}} (\bm{q}_k, t), \\
    \Delta \bm{q}_k &= -\bm{J}_k^\top (\bm{J}_k \bm{J}_k^\top)^{-1} \bm{\Phi}_k, \\
    \bm{q}_{k+1} &= \bm{q}_k + \Delta \bm{q}_k.
\end{align}

The iteration continues until \( \| \bm{\Phi}(\bm{q}_k, t) \| < \epsilon \) for
some small threshold \( \epsilon \). This Newton-based projection ensures that
\( \bm{q}_{\text{proj}} \) lies on the constraint manifold up to numerical
precision.

\subsubsection*{Remarks}

\begin{itemize}
    \item The method assumes \( \bm{J} \bm{J}^\top \) is invertible. This
    requires that the constraints be independent and not overdetermined.
    \item If the system has mass-inertia structure, the projection can be
    modified to minimize in the kinetic energy norm using the generalized mass
    matrix \( \bm{M} \). This leads to:
    \[
        \Delta \bm{q} = -\bm{M}^{-1} \bm{J}^\top (\bm{J} \bm{M}^{-1} \bm{J}^\top)^{-1} \bm{\Phi}(\bm{q}^*, t),
    \]
    which corresponds to the least kinetic energy correction.
\end{itemize}

\subsection{Baumgarte Stabilization}

We enforce constraints at the acceleration level with proportional-derivative
feedback:

\begin{equation}
    \bm{J} \bm{N} \dot{\bm{v}} + \dot{\bm{J}} \bm{N} \bm{v} + 2\alpha \bm{J} \bm{N} \bm{v} + \beta^2 \bm{\Phi}(\bm{q}, t) = -\frac{\partial \bm{\Phi}}{\partial t},
\end{equation}

where \( \alpha \), \( \beta \) are tunable gains.

\section{Penalty-Based Methods (Soft Constraints)}

Constraints are enforced approximately by adding a penalizing force:

\begin{equation}
    \bm{\tau}_{\text{penalty}} = -k_p \bm{J}^\top \bm{\Phi}(\bm{q}, t) - k_d \bm{J}^\top \bm{J} \bm{N} \bm{v},
\end{equation}

with \( k_p \) and \( k_d \) being stiffness and damping coefficients,
respectively. This turns the hard constraint into a stiff but solvable
unconstrained problem.

\end{document}
